////
Copyright Glen Knowles 2016 - 2024.
Distributed under the Boost Software License, Version 1.0.
////

= User's Guide
:idprefix:
:idseparator: -

== Overview
C++ command line parser toolkit for kids of all ages.

* GNU style command lines (-o, --output=FILE, etc.)
* Parses to any supplied (or implicitly created) variable whose type is:
** Default constructible
** Copyable
** Either assignable from string, constructible from string, has an istream
   extraction operator, or has a specialization of
   Cli::Convert::fromString&lt;T>()
* Help generation.
* Option definitions can be scattered across multiple files.
* Git style subcommands.
* Response files (requires `<filesystem>` support).
* Convert argv to/from command line with Windows, Posix, or GNU semantics.
* Wordwrap arbitrary paragraphs and simple text tables for console output.
* Works whether or not exceptions and RTTI are disabled.
* Distributed under the Boost Software License, Version 1.0.

=== Sample Usage
How does it feel?

[source, C++, test prefix 0]
////
#include "dimcli/cli.h"
#include <iostream>
using namespace std;

constexpr unsigned EX_OK = Dim::kExitOk;
constexpr unsigned EX_USAGE = Dim::kExitUsage;
constexpr unsigned EX_SOFTWARE = Dim::kExitSoftware;

////

[source, C++, test subset 4]
----
#include "dimcli/cli.h"
#include <iostream>
using namespace std;

int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & count = cli.opt<int>("c n count", 1).desc("times to say hello");
    auto & name = cli.opt<string>("name", "Unknown").desc("who to greet");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr); // prints error and returns cli.exitCode()
    if (!name)
        cout << "Greeting the unknown." << endl;
    for (int i = 0; i < *count; ++i)
        cout << "Hello " << *name << "!" << endl;
    return 0;
}
----
What it does when run:

[source, shell session]
----
$ a.out -x
Error: Unknown option: -x

$ a.out --help
Usage: a.out [OPTIONS]

Options:
  -c, -n, --count=NUM  times to say hello (default: 1)
  --name=STRING        who to greet (default: Unknown)

  --help               Show this message and exit.

$ a.out --count=3
Greeting the unknown.
Hello Unknown!
Hello Unknown!
Hello Unknown!
$ a.out --name John
Hello John!
----

=== Use in Your Project
You can get the code into your project in several different ways, here are a
few:

*Copy source directly into your project*

All you need is:

* libs/dimcli/cli.h
* libs/dimcli/cli.cpp

*Use https://github.com/Microsoft/vcpkg[vcpkg]*

* vcpkg install dimcli

*Build with cmake*

. Get the latest https://github.com/gknowles/dimcli/releases[dimcli] release.
. Build as a library (this example uses Visual C++ 2015 to install a 64-bit
  build to c:\dimcli on a windows machine):
** md build & cd build
** cmake .. -DCMAKE_INSTALL_PREFIX=c:\dimcli -G "Visual Studio 14 2015 Win64"
** cmake --build .
** ctest -C Debug
** cmake --build . --target install


== Basics

=== Terminology
Following POSIX conventions, this document uses the terms "*options*" to refer
to named arguments, some times known as switches or flags. And "*operands*" for
positional arguments that are distinguished only by the order they appear on
the command line after the options have been removed.

For example:

`prog FILE1 -v --help -f FILE --file=FILE FILE2`

Might (depending on how -f and --file are defined) map to:
[%autowidth]
|===
h| Options | -v, --help, -f FILE, --file=FILE
h| Operands | FILE1, FILE2
|===

=== Basic Usage
After inspecting args cli.parse() returns false if it thinks the program
should exit, in which case cli.exitCode() is either EX_OK (0) or EX_USAGE (64)
for early exit (like --help) or bad arguments respectively. Otherwise the
command line was valid, arguments have been parsed, and cli.exitCode() is
EX_OK.

[source, C++, test subset 5]
----
#include "dimcli/cli.h"
#include <iostream>
#include <sysexits.h> // if you want the unix exit code macros (EX_*)
using namespace std;

int main(int argc, char * argv[]) {
    Dim::Cli cli;
    if (!cli.parse(argc, argv))
        return cli.printError(cerr); // prints error and returns cli.exitCode()
    cout << "Does the apple have a worm? No!";
    return EX_OK;
}
----

And what it looks like:

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  --help    Show this message and exit.

$ a.out
Does the apple have a worm? No!
----

The EX_* constants (along with standard values) are in `<sysexits.h>` on most
unixes, although it may not be in any standard. Equivalent enum values
Dim::kExitOk (0) and Dim::kExitUsage (64) are defined, which can be useful on
Windows where `<sysexits.h>` doesn't exist.


=== Options
Dim::Cli is used by declaring options to receive arguments. The variable that
receives the value is specified when the option is declared, either as a
pointer to an existing external variable or implicitly created.

Use cli.opt&lt;T>(names, defaultValue) to link options and operands to a
variable. It returns a proxy object that can be used like a smart pointer (*
and \->) to access the value.

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & fruit = cli.opt<string>("fruit", "apple");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "Does the " << *fruit << " have a worm? No!";
    return EX_OK;
}
----

And what you get:

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  --fruit=STRING  (default: apple)

  --help          Show this message and exit.

$ a.out --fruit=orange
Does the orange have a worm? No!
$ a.out --fruit orange
Does the orange have a worm? No!
----

Add a description and change the value's name in the description:

[source, C++, test repl 2 1]
----
auto & fruit = cli.opt<string>("fruit", "apple")
    .desc("type of fruit")
    .valueDesc("FRUIT");
----
And you get:

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  --fruit=FRUIT  type of fruit (default: apple)

  --help         Show this message and exit.
----


=== External Variables
In addition to using the option proxies you can bind options directly to
existing variables. This can be used to set a global flag or populate a struct
that you access later.

For example:

[source, C++]
----
int main(int argc, char * argv[]) {
    bool worm;
    Dim::Cli cli;
    cli.opt(&worm, "w worm").desc("make it icky");
    auto & fruit = cli.opt<string>("fruit", "apple").desc("type of fruit");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "Does the " << *fruit << " have a worm? "
        << (worm ? "Yes :(" : "No!");
    return EX_OK;
}
----
And what it looks like:

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  --fruit=STRING          type of fruit (default: apple)
  -w, --worm / --no-worm  make it icky

  --help                  Show this message and exit.

$ a.out --fruit=orange
Does the orange have a worm? No!
$ a.out -w
Does the apple have a worm? Yes :(
----

You can also point multiple options at the same variable, as is common with
<<#flag-values, flag values>>.


=== Option Names
Names are passed in as a whitespace separated list where the individual names
take one of four types:

[%autowidth]
|===
| Type of name                              | Example

| short name (single character)             | f or (f)
| long name (more than one character)       | file or (file)
| optional operand (within square brackets) | [file name]
| required operand (within angle brackets)  | &lt;file>
|===

[%autowidth, cols="^,<"]
|===
h| Prefixes |
| ! | For boolean options, when setting the value it is first inverted.
| ? | For non-boolean options, makes the value <<#optional-values, optional>>.
| * | For options, makes it take a <<#value-list, value list>>.

2+<h| Suffixes
| . | For boolean options with long names, suppresses the addition of the "no-"
version.
| ! | Final option, all following arguments will be positional operands.
|===

.Additional rules
* Names of operands (inside angled or square brackets) may contain whitespace.
* Option names must
** Start and end with an alpha numeric character; or
** Be enclosed in parentheses; or
** Be a single character, other than '(', '[', and '<', without modifiers
* Within parentheses a ')' pair is treated as a literal ')' and doesn't close
the parenthetical. Likewise for ']' and '>' within square and angled brackets
respectively.
* Long names for boolean options get a second "no-" version implicitly created
for them.

[%autowidth]
|===
| Example | Meaning

| f file    | Short name 'f' and long name "file"
| f [file]  | Short name 'f' and optional operand
| !         | Short name '!'
| ?!<br>!!. | Error - no name, only modifiers
| ?(!)      | Short name '!' with optional value
| (!!).     | Long name "!!", without "no-!!" version
| ?a.b.c.   | Long name "a.b.c" with option value and without "no-"
| ())) ([)  | Short names ')' and '['
|===

For example:

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    cli.opt<string>("a apple [APPLE]").desc("apples are red");
    cli.opt<bool>("!o orange apricot.").desc("oranges are orange");
    cli.opt<string>("<PEAR>").desc("pears are yellow");
    (void) cli.parse(argc, argv);
    return EX_OK;
}
----
Ends up looking like this (note: required operands have priority, so [APPLE]
won't be set unless there are at least two arguments):

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS] [APPLE] PEAR
  APPLE     apples are red
  PEAR      pears are yellow

Options:
  -a, --apple=STRING  apples are red
  --orange, --apricot / -o, --no-orange
                      oranges are orange

  --help              Show this message and exit.
----

When named options are added they replace any previous rule with the same
name, therefore this option declares '&#8209;n' an inverted bool:

[source, C++]
----
cli.opt<bool>("n !n");
----
But with this combination it becomes '-n STRING', a string:

[source, C++]
----
cli.opt<bool>("n !n");
cli.opt<string>("n");
----


=== Operands
A few things to keep in mind about operands (positional arguments):

* Operands are mapped in the order they were added.
** Except that optional operands are populated only if there are enough other
   arguments to satisfy all required operands.
* If there are multiple vector operands with unlimited (max size = -1) arity
  the first will get all the extras.
* If there is a required operand with unlimited arity it will prevent any
  optional operands from getting populated, since it consumes all the arguments
  before the optionals get a turn.

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & a = cli.opt<int>("[A]");
    auto & b = cli.optVec<int>("<B>").size(1, 2); // take 1 to 2 values
    auto & c = cli.opt<int>("<C>");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    if (a) cout << "A:" << *a << ' ';
    for (int val : *b) cout << "B:" << val << ' ';
    if (c) cout << "C:" << *c << ' ';
    return EX_OK;
}
----

A few combinations to show how this plays out:

[source, shell session]
----
$ a.out
Error: Option 'B' missing value.
Must have 1 to 2 values.
$ a.out 1
Error: Option 'C' missing value.
$ # With two args 'A' is not populated as it's optional whlie 'B' & 'C'
$ # are required.
$ a.out 1 2
B:1 C:2
$ a.out 1 2 3
B:1 B:2 C:3
$ # With four args we have enough left for 'A' after populating 'B' & 'C'.
$ a.out 1 2 3 4
A:1 B:2 B:3 C:4
$ a.out 1 2 3 4 5
Error: Unexpected argument: 5
----


=== Flag Options
Many options are flags with no associated value, they just set an option
to a predefined value. This is the default when you create a option of type
bool. Normally flags set the option to true, but this can be changed in two
ways:

* Make it an inverted bool, which will set it to false
** Explicitly using the "!" modifier
** Define a long name and use the implicitly created "no-" prefix version
* Use opt.flagValue() to set the value, see
  <<##flag-values, flag values>>.

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & shout = cli.opt<bool>("shout !whisper").desc("I can't hear you!");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    string prog = cli.progName();
    if (*shout) {
        auto & f = use_facet<ctype<char>>(cout.getloc());
        f.toupper(prog.data(), prog.data() + prog.size());
        prog += "!!!!111";
    }
    cout << "I am " << prog;
    return EX_OK;
}
----
What you see:

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  --shout, --no-whisper / --no-shout, --whisper
            I can't hear you!

  --help    Show this message and exit.

$ a.out
I am a.out
$ a.out --shout
I am A.OUT!!!!111
$ a.out --no-whisper
I am A.OUT!!!!111
----


=== Vector Options
Allows for an unlimited (or specific) number of values to be returned in a
vector. Vector options are declared using cli.optVec() which binds to a
std::vector&lt;T>.

Example:

[source, C++]
----
// Printing a comma separated list is annoying...
template<typename T>
ostream & operator<< (ostream & os, const vector<T> & v) {
    auto i = v.begin(), e = v.end();
    if (i != e) {
        os << *i++;
        for (; i != e; ++i) os << ", " << *i;
    }
    return os;
}

int main(int argc, char * argv[]) {
    Dim::Cli cli;
    // For oranges demonstrate using an external vector, and limit the
    // maximum number to 2.
    vector<string> oranges;
    cli.optVec(&oranges, "o orange").size(1, 2).desc("oranges");
    // For apples demonstrate using just the proxy object.
    auto & apples = cli.optVec<string>("[APPLE]").desc("red fruit");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "Comparing (" << *apples << ") and (" << oranges << ").";
    return EX_OK;
}
----
View from the command line:

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS] [APPLE...]
  APPLE     red fruit

Options:
  -o, --orange=STRING  oranges (limit: 1 to 2)

  --help               Show this message and exit.

$ a.out -o mandarin -onavel "red delicious" honeycrisp
Comparing (red delicious, honeycrisp) and (mandarin, navel).
$ a.out -omandarin -onavel -ohamlin
Error: Too many '-o' values: hamlin
The maximum number of values is 2.
----

While the * and \-> operators get you full access to the underlying vector,
size() and [] are also available directly on OptVec&lt;T>. Which may
occasionally save a little bit of typing.

[source, C++]
----
auto & apples = cli.optVec<string>("[APPLE]").desc("red fruit");
...
cout << "There were " << apples.size() << " apples." << endl;
if (apples)
    cout << "The first was " << apples[0] << endl;
----

By default a vector option will accept any number of values, this can be
changed using optVec.size(N) or .size(MIN, MAX).

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    cli.optVec<int>("v").size(2, 3).desc("Test value.");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "Success";
    return EX_OK;
}
----

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  -v NUM    Test value. (limit: 2 to 3)

  --help    Show this message and exit.

$ a.out -v1
Error: Option '-v' missing value.
Must have 2 to 3 values.
$ a.out -v1 -v1
Success
$ a.out -v1 -v1 -v1 -v1
Error: Too many '-v' values: 1
The maximum number of values is 3.
----

=== Life After Parsing
If you are using external variables you just access them directly after using
cli.parse() to populate them.

If you use the proxy object returned from cli.opt&lt;T>() you can dereference
it like a smart pointer to get at the value. In addition, you can test whether
it was explicitly set, find the argument name that populated it, and get the
position in argv[] it came from.

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & name = cli.opt<string>("n name", "Unknown");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    if (!name) {
        cout << "Using the unknown name." << endl;
    } else {
        cout << "Name selected using " << name.from()
            << " from argv[" << name.pos() << "]" << endl;
    }
    cout << "Hello " << *name << "!" << endl;
    return EX_OK;
}
----
What it does:

[source, shell session]
----
$ a.out
Using the unknown name.
Hello Unknown!
$ a.out -n John
Name selected using -n from argv[2]
Hello John!
$ a.out --name Mary
Name selected using --name from argv[2]
Hello Mary!
----

If you want a little more control over error output you can use the two
argument version of cli.parse() and then inspect the results with
cli.exitCode(), cli.errMsg(), and cli.errDetail().

[source, C++]
----
if (!cli.parse(argc, argv))
    return cli.exitCode();
----

Because (unless you use CliLocal) there is a single program wide command line
context, you can make an error handler that doesn't have to be passed the
results.

[source, C++]
----
void failed() {
    Dim::Cli cli;
    cli.printError(cerr);
    exit(cli.exitCode());
}

int main(int argc, char * argv[]) {
    Dim::Cli cli;
    if (!cli.parse(argc, argv))
        failed();
    ...
    return EX_OK;
}
----

== Advanced

=== Special Arguments

[%autowidth]
|===
| Value        | Description

| "-"          | Passed in as an operand.
| "--"         | Thrown away, but all remaining arguments are treated as
                 operands.
| "@&lt;file>" | <<#response-files, Response file>> containing additional
                 arguments.
|===


=== Optional Values
You use the '?' <<#option-names, flag>> on an option name to indicate that its
value is optional. Long named booleans are generally evaluated on their
presence or absence, but also allow optional values such as "true", "false",
"yes", or "1".

For a user to set a value on the command line when it is optional the value
must be attached (no space) to the option name, otherwise it is interpreted
as not present and the options implicit value is used instead. If the name
is not present at all the variable is set to the default given in the
cli.opt&lt;T>() call.

By default the implicit value is T{}, but can be changed using
opt.implicitValue().

For example:

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & v1 = cli.opt<string>("?o ?optional", "default").desc("v1");
    auto & v2 = cli.opt<string>("?i ?with-implicit", "default").desc("v2");
    v2.implicitValue("implicit");
    auto & p = cli.opt<string>("[OPERAND]", "default");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "v1 = " << *v1 << ", v2 = " << *v2 << ", p = " << *p;
    return EX_OK;
}
----
What happens:

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS] [OPERAND]

Options:
  -i, --with-implicit[=STRING]  v2 (default: default)
  -o, --optional[=STRING]       v1 (default: default)

  --help                        Show this message and exit.

$ a.out
v1 = default, v2 = default, p = default
$ a.out -oone -i two
v1 = one, v2 = implicit, p = two
$ a.out -o one -itwo
v1 = , v2 = two, p = one
$ a.out --optional=one --with-implicit two
v1 = one, v2 = implicit, p = two
$ a.out --optional one --with-implicit=two
v1 = , v2 = two, p = one
----


=== Value List
The '*' <<#option-names, flag>> on an option name enables value lists. A
specific name can't have both an optional value and a value list. If an option
with a value list has an attached value only that value is matched with the
option. Otherwise the next argument is matched and additional following
arguments up to the next option are also matched. However, if the option is an
optVec, additional arguments will stop being matched after opt.maxSize() is
reached.

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & words = cli.optVec<string>("*words").desc("Words to process.");
    cli.opt<bool>("z").desc("Another flag.");
    auto & extra = cli.opt<string>("[extra]");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "Words: ";
    for (auto && word : *words)
        cout << word << " ";
    if (extra)
        cout << "\nExtra: " << *extra;
    return EX_OK;
}
----

How this works out:

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS] [extra]

Options:
  --words=STRING...  Words to process.
  -z                 Another flag.

  --help             Show this message and exit.

$ a.out
Words:
$ a.out --words=one two
Words: one
Extra: two
$ a.out --words one two three
Words: one two three
$ a.out --words one two -z three
Words: one two
Extra: three
----


=== Flag Values
Flag values are implemented by creating multiple options that reference the
same external variable and marking them as flag values. These flag options are
then processed on the command line as if they were boolean. But when matched,
instead of true, they set the variable to the default the option was created
with.

To set one of the flag values as the default, pass in a value of true to the
flagValue() function called for that option.

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    string fruit;
    // "~" is the default option group for --help, --version, etc. Give
    // it a title so it doesn't look like more fruit.
    cli.group("~").title("Other options");
    cli.group("Type of fruit");
    cli.opt(&fruit, "o orange", "orange").desc("oranges").flagValue();
    cli.opt(&fruit, "a", "apple").desc("red fruit").flagValue(true);
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "Does the " << fruit << " have a worm? No!";
    return EX_OK;
}
----
Which looks like:

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Type of fruit:
  -a            red fruit (default)
  -o, --orange  oranges

Other options:
  --help        Show this message and exit.

$ a.out
Does the apple have a worm? No!
$ a.out -o
Does the orange have a worm? No!
----
You can use an inaccessible option (empty string for the names) that doesn't
show up in the interface (or the help text) to set an explicit default.

[source, C++, test repl 7 2]
----
cli.opt(&fruit, "o orange", "orange").desc("oranges").flagValue();
cli.opt(&fruit, "a", "apple").desc("red fruit").flagValue();
cli.opt(&fruit, "", "fruit").flagValue(true);
----
Now instead of an apple there's a generic fruit default.

[source, shell session]
----
$ a.out
Does the fruit have a worm? No!
----

Here's an example that uses opt.nameDesc() to make the help text for multiple
flag values more concise:

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & lvl = cli.opt<int>("1", 1).flagValue(true)
        .nameDesc("-1, -2, -3")
        .desc("Level to use. (default: 1)")
        .defaultDesc("");
    cli.opt<int>(lvl, "2", 2).flagValue().show(false);
    cli.opt<int>(lvl, "3", 3).flagValue().show(false);
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "Level " << *lvl << " selected.";
    return EX_OK;
}
----
Which gives you:

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  -1, -2, -3  Level to use. (default: 1)

  --help      Show this message and exit.

$ a.out
Level 1 selected.
$ a.out -2
Level 2 selected.
----


=== Before Actions
It's unusual to want a before action. They operate on the entire argument
list, after environment variable and response file expansion, but before any
individual arguments are parsed. The before action should:

* Inspect and possibly modify the raw arguments. The args are guaranteed to
  start out valid, but be careful that it still starts with a program name
  in arg0 when you're done.
* Call cli.badUsage() with an error message for problems.
* Call cli.parseExit() if parsing should stop, but there was no error.

There can be any number of before actions, they are executed in the order
they are added.

Let's test for empty command lines and add "--help" to them. But first, our
"before" program:
[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & val = cli.opt<string>("<VALUE>").desc("It's required!");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "The value: " << *val;
    return EX_OK;
}
----

And it's output:
[source, shell session]
----
$ a.out 99
The value: 99
$ a.out --help
Usage: a.out [OPTIONS] VALUE
  VALUE     It's required!

Options:
  --help    Show this message and exit.

$ a.out
Error: Option 'VALUE' missing value.
----

Now add the before action:
[source, C++, test repl 2 0]
----
cli.before([](Dim::Cli &, vector<string> & args) {
    if (args.size() == 1) {
        // It's just the program name, add the help option.
        args.push_back("--help");
    }
});
----

And missing arguments are a thing of the past...
[source, shell session]
----
$ a.out
Usage: a.out [OPTIONS] VALUE
  VALUE     It's required!

Options:
  --help    Show this message and exit.
----

That isn't too complicated, but since this case is so common cli.helpNoArgs()
is available to do the same thing.


=== Parse Actions
Sometimes, you want an argument to completely change the execution flow. For
instance, to provide more detailed errors about badly formatted arguments. Or
to make "--version" print some crazy ASCII artwork and exit the program (for
a non-crazy --version use <<#version-option, opt.versionOpt()>>).

Parsing actions are bound to options and get invoked when a value becomes
available for it. Any std::function compatible object that accepts references
to cli, opt, and string as parameters can be used. The function should:

* Parse the source string and use the result to set the option value (or
  push back the additional value for vector arguments).
* Call cli.badUsage() with an error message if there's a problem.
* Call cli.parseExit() if the program should stop. This could be due to an
  early out like "--version" and "--help".

Other things to keep in mind:

* Options only have one parse action, changing it *replaces* the default.
* You can use opt.from() and opt.pos() from within the action to get the
  option name that the value matched with and its position in argv[].
* For bool options the source value string will always be either "0" or "1".

Here's an action that multiples multiple values together:
[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & product = cli.opt<int>("n number", 1)
        .desc("numbers to multiply")
        .parse([](auto & cli, auto & opt, const string & val) {
            int tmp = *opt; // save the old value
            if (!opt.parseValue(val)) // parse the new value into opt
                return cli.badUsage(opt, val);
            *opt *= tmp; // multiply old and new together
        });
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "The product is: " << *product << endl;
    return EX_OK;
}
----

Let's do some math!
[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  -n, --number=NUM  numbers to multiply (default: 1)

  --help            Show this message and exit.

$ a.out
The product is: 1
$ a.out -n3 -n2
The product is: 6
$ a.out -nx
Error: Invalid '-n' value: x
----


=== Check Actions
Check actions run for each value that is successfully parsed and are a good
place for additional work. For example, opt.range() and opt.clamp() are
implemented as check actions. Just like parse actions the callback is any
std::function compatible object that accepts references to cli, opt, and
string as parameters and returns bool.

An option can have any number of check actions and they are called in the
order they were added.

The function should:

* Check the options new value. Beware that options are process in the order
  they appear on the command line, so comparing with another option is
  usually better done in an <<#after-actions, after action>>.
* Call cli.badUsage() with an error message if there's a problem.
* Call cli.parseExit() if the program should stop without an error.

The opt is fully populated, so *opt, opt.from(), etc are all available.

Sample check action that rounds up to an even number of socks:
[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & socks = cli.opt<int>("socks")
        .desc("Number of socks, rounded up to even number.")
        .check([](auto & cli, auto & opt, auto & val) {
            *opt += *opt % 2;
        });
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << *socks << " socks";
    if (*socks) cout << ", where are the people?";
    cout << endl;
    return EX_OK;
}
----

Let's... wash some socks?
[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  --socks=NUM  Number of socks, rounded up to even number. (default: 0)

  --help       Show this message and exit.

$ a.out
0 socks
$ a.out --socks 3
4 socks, where are the people?
----


=== After Actions
After actions run after all arguments have been parsed. For example,
opt.prompt() and opt.require() are both implemented as after actions. Any
number of after actions can be added and will, for every (not just the
ones referenced by the command line!) registered option, be called in the
order they're added. They are called with the three parameters, like other
option actions, that are references to cli, opt, and the value string
respectively. However the value string is always empty(), so any information
about the value must come from the opt reference.

When using subcommands, only the after actions bound to the top level or the
selected command are executed. After actions on the options of all other
commands are, like the options themselves, ignored.

The function should:

* Do something interesting.
* Call cli.badUsage() and return on error.
* Call cli.parseExit() if processing should stop without error.

Action to make sure the high is not less than the low:
[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & low = cli.opt<int>("l").desc("Low value.");
    auto & high = cli.opt<int>("h")
        .desc("High value, must be greater than or equal to the low.")
        .after([&](auto & cli, auto & opt, auto &) {
            if (*opt < *low)
                cli.badUsage("High must not be less than the low.");
        });
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "Range is from " << *low << " to " << *high << endl;
    return EX_OK;
}
----

Set the range:
[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  -h NUM    High value, must be greater than or equal to the low. (default: 0)
  -l NUM    Low value. (default: 0)

  --help    Show this message and exit.

$ a.out
Range is from 0 to 0
$ a.out -l1
Error: High must not be less than the low.
$ a.out -h5 -l2
Range is from 2 to 5
----


=== Subcommands
Git style subcommands are created by either cli.command("cmd"), which changes
the cli objects context to the command, or with opt.command("cmd"), which
changes the command that option is for. Once the cli object context has been
changed it can than be used to add (description, footer, options, etc) to the
command. Exactly the same as when working with a simple command line. If you
pass an empty string to cli.command() or opt.command() it represents the top
level processing that takes place before a command has been found.

Options are processed on the top level along with the minimum number of
operands needed to satisfy its required operands. The next following operand is
the command, and the rest of the arguments are processed in the context of that
command. Since the top level doesn't process optional or variable length
operands when commands are present, their definitions will assert in debug
builds and be ignored in release.

[source, C++]
----
static auto & yell = Dim::Cli().opt<bool>("yell.").desc("Say it loud.");
static auto & color = Dim::Cli().opt<string>("color", "red")
    .command("apple")
    .desc("Change color of the apple.");

bool apple(Dim::Cli & cli) {
    cout << "It's a " << *color << " apple" << (*yell ? "!!!" : ".");
    return true;
}

bool orange(Dim::Cli & cli) {
    cout << "It's an orange" << (*yell ? "!!!" : ".");
    return true;
}

int main(int argc, char * argv[]) {
    Dim::Cli cli;
    cli.command("apple").desc("Show apple. No other fruit.").action(apple);
    cli.command("orange").desc("Show orange.").action(orange);
    cli.exec(argc, argv);
    return cli.printError(cerr);
}
----

The same thing could also be done with external variables:

[source, C++, test alt, test repl 6 1 11 1]
////
    cout << "It's a " << color << " apple" << (yell ? "!!!" : ".");
    ...
    cout << "It's an orange" << (yell ? "!!!" : ".");
////

[source, C++, test repl 0 4 14 3]
----
static bool yell;
static string color;
...

int main(int argc, char * argv[]) {
    Dim::Cli cli;
    cli.opt(&yell, "yell.").desc("Say it loud.");
    cli.opt(&color, "color", "red").command("apple")
        .desc("Change color of the apple.");
    ...
----

Or if there's some additional argument checks or setup you need to do, the
exec() call can be separate from parse():
[source, C++, test alt, test repl 20 2]
----
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    // any additional validation...
    cli.exec();
    return cli.printError(cerr);
----

The end result at the console:
[source, shell session]
----
$ a.out
Error: No command given.
$ a.out --help
Usage: a.out [OPTIONS] COMMAND [ARGS...]

Commands:
  apple     Show apple.
  orange    Show orange.

Options:
  --yell    Say it loud.

  --help    Show this message and exit.

$ a.out apple
It's a red apple.
$ a.out apple --color=yellow
It's a yellow apple.
$ a.out orange
It's an orange.
$ a.out --yell orange
It's an orange!!!
----

In the commands list, only the first sentence of cli.desc() (up to the first
'.', '!', or '?' that's followed by a space) is shown, but in command specific
pages you see the whole thing:

[source, shell session]
----
$ a.out apple --help
Usage: a.out apple [OPTIONS]

Show apple. No other fruit.

Options:
  --color=STRING  Change color of the apple. (default: red)

  --help          Show this message and exit.
----

==== External Commands
In order to support an external command that processes its own command line you
can set an unknown command action. That action will be called by cli.exec(),
like any other command action, but only for commands that don't match any of
the defined commands. Alternatively, after parsing, instead of calling
cli.exec() you can use cli.commandMatched() and cli.unknownArgs() to see what
matched.

When the matched command is unknown, the unknownArgs vector is populated with
the all arguments that follow the command. Including any that started with "-",
as if <<#special-arguments, "--">> had been given.

[source, C++]
----
bool unknown(Dim::Cli & cli) {
    cout << "Command: " << cli.commandMatched() << endl;
    for (auto&& arg : cli.unknownArgs())
        cout << "Arg: " << arg << endl;
    return false;
}

int main(int argc, char * argv[]) {
    Dim::Cli cli;
    cli.unknownCmd(unknown);
    cli.exec(argc, argv);
    return cli.printError(cerr);
}
----

[source, shell session]
----
$ a.out
Error: No command given.
$ a.out test 1 2 3
Command: test
Arg: 1
Arg: 2
Arg: 3
----

An regular command can also be configured to populate the unknownArgs vector
instead of normal options/operands via cli.unknownArgs(bool enable)

[source, C++, test repl 7 6]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    cli.command("echo").action(unknown).unknownArgs(true);
    cli.exec(argc, argv);
    return cli.printError(cerr);
}
----

[source, shell session]
----
$ a.out test 1 2 3
Error: Unknown command: test
$ a.out echo a b c
Command: echo
Arg: a
Arg: b
Arg: c
----

=== Multiple Source Files
Options don't have to be defined all in one source file. Separate source
files can each define options of interest to that file and get them populated
when the command line is processed.

When you instantiate Dim::Cli you're creating a handle to the globally shared
configuration. So multiple translation units can each create one and use it to
update the shared configuration.

The following example has a logMsg function in log.cpp with its own "-1"
option while main.cpp registers "--version":

[source, C++]
----
// main.cpp
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    cli.versionOpt("1.0");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    // do stuff that might call logMsg()...
    return EX_OK;
}
----

[source, C++, test file log]
----
// log.cpp
static Dim::Cli cli;
static auto & failEarly = cli.opt<bool>("1").desc("Exit on first error");

void logMsg(string & msg) {
    cerr << msg << endl;
    if (*failEarly)
        exit(EX_SOFTWARE);
}
----

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  -1         Exit on first error

  --help     Show this message and exit.
  --version  Show version and exit.
----

When you want to put a bundle of stuff in a separate source file, such as a
<<#subcommands, command>> and its options, it can be convenient to group them
into a single static struct.
[source, C++, test file somefile]
----
// somefile.cpp
static int myCmd(Dim::Cli & cli);

static struct CmdOpts {
    int option1;
    string option2;
    string option3;

    CmdOpts() {
        Dim::Cli cli;
        cli.command("my").action(myCmd).desc("What my command does.");
        cli.opt(&option1, "1 one", 1).desc("First option.");
        cli.opt(&option2, "2", "two").desc("Second option.");
        cli.opt(&option3, "three", "three").desc("Third option.");
    }
} s_opts;
----

[source, C++, test file somefile, test repl 15 0]
////

static int myCmd(Dim::Cli &) {
    return s_opts.option1;
}
////
++++
++++

Then in myCmd() and throughout the rest of somefile.cpp you can reference the
options as **s_opts.option1**, **s_opts.option2**, and **s_opts.option3**.

And the help text will be:
[source, shell session]
----
$ a.out my --help
Usage: a.out my [OPTIONS]

What my command does.

Options:
  -1, --one=NUM   First option. (default: 1)
  -2 STRING       Second option. (default: two)
  --three=STRING  Third option. (default: three)

  --help          Show this message and exit.
----


=== Multiple Parsers
You can use Dim::CliLocal if you need to redefine options, have results from
multiple parses at once, or otherwise avoid the shared configuration.

Like Dim::Cli, Dim::CliLocal is a handle to a configuration, but instead of
the shared configuration it's default constructor creates a new
configuration instance and references that instead.

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::CliLocal c1;
    c1.opt<string>("one").desc("Option of first command line parser.");
    Dim::CliLocal c2;
    c2.opt<string>("two").desc("Option of second command line parser.");

    c1.printUsageEx(cout, "first");
    c2.printUsageEx(cout, "second");
    return EX_OK;
}
----

[source, shell session]
----
$ a.out
Usage: first [--one=STRING] [--help]
Usage: second [--two=STRING] [--help]
----


=== Response Files
A response file is a collection of frequently used or generated arguments
saved as text, often with a ".rsp" extension, that is substituted into the
command line when referenced.

What you write:

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & words = cli.optVec<string>("[WORDS]").desc("Things you say.");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "Words:";
    for (auto & w : *words)
        cout << " " << w;
    return EX_OK;
}
----
What happens later:

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS] [WORDS...]
  WORDS     Things you say.

Options:
  --help    Show this message and exit.

$ a.out a b
Words: a b
$ echo c >one.rsp
$ a.out a b @one.rsp d
Words: a b c d
----
Response files can be used multiple times and the arguments in them can be
broken into multiple lines:

[source, shell session]
----
$ echo d >one.rsp
$ echo e >>one.rsp
$ a.out x @one.rsp y @one.rsp
Words: x d e y d e
----
Response files also can be nested, when a response file contains a reference
to another response file the path is relative to the parent response file,
not to the working directory.

[source, shell session]
----
$ md rsp
$ echo one @more.rsp >rsp/one.rsp
$ echo two three >rsp/more.rsp
$ a.out @rsp/one.rsp
Words: one two three
----

Recursive response files will fail, don't worry!
[source, shell session]
----
$ echo "@one.rsp" >one.rsp
$ a.out @one.rsp
Error: Recursive response file: one.rsp
----

While generally useful response file processing can be disabled via
cli.responseFiles(false).


=== Environment Variable
You can specify an environment variable that will have its contents
prepended to the command line. This happens before response file expansion
and any before actions.

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & words = cli.optVec<string>("[WORDS]");
    cli.envOpts("AOUT_OPTS");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "Words:";
    for (auto && word : *words)
        cout << " '" << word << "'";
    return EX_OK;
}
----
The same can also be done manually, as shown below. This is a good starting
point if you need something slightly different:

[source, C++, test repl 3 3, test alt]
----
vector<string> args = cli.toArgv(argc, argv);
if (const char * eopts = getenv("AOUT_OPTS")) {
    vector<string> eargs = cli.toArgv(eopts);
    // Insert the environment args after arg0 (program name) but before
    // the rest of the command line.
    args.insert(args.begin() + 1, eargs.begin(), eargs.end());
}
if (!cli.parse(args))
    return cli.printError(cerr);
----

Or as a before action (after response file expansion):
[source, C++, test repl 3 9, test alt]
----
cli.before([](Dim::Cli & cli, vector<string> & args) {
    if (const char * eopts = getenv("AOUT_OPTS")) {
        vector<string> eargs = cli.toArgv(eopts);
        args.insert(args.begin() + 1, eargs.begin(), eargs.end());
    }
    return true;
});
if (!cli.parse(argc, argv))
    return cli.printError(cerr);
----

How this works:

[source, shell session]
----
$ export AOUT_OPTS=
$ a.out c d
Words: 'c' 'd'
$ export "AOUT_OPTS=a b"
$ a.out c d
Words: 'a' 'b' 'c' 'd'
----


=== Keep It Quiet
For some applications, such as Windows services, it's important not to
interact with the console. Simple steps to avoid cli.parse() doing console IO:

1. Don't use things (such as opt.prompt()) that explicitly ask for IO.
2. Add your own "help" argument to override the default, you can still turn
around and call cli.printHelp(ostream&) if desired.
3. Use the two argument version of cli.parse() and get the error message from
cli.errMsg() and cli.errDetail() if it fails.


== Options and Modifiers

=== Version Option
Use cli.versionOpt() to add simple --version processing.

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    cli.versionOpt("1.0");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "Hello world!" << endl;
    return EX_OK;
}
----

Is version 1.0 ready to ship?
[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  --help     Show this message and exit.
  --version  Show version and exit.

$ a.out --version
a.out version 1.0
$ a.out
Hello world!
----


=== Help Option
You can modify the implicitly created --help option. Use cli.helpOpt() to get a
reference and then go to town. The most likely thing would be to change the
description or option group, but since you get back an Opt&lt;T> you can use
any of the standard functions.

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    cli.helpOpt();
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    return EX_OK;
}
----

And when run...
[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  --help    Show this message and exit.
----

It can be modified like any other bool option.
[source, C++, test repl 2 1]
----
cli.helpOpt().desc("What you see is what you get.");
----
[source, C++, test alt, test repl 2 1]
----
auto & help = cli.helpOpt();
help.desc("What you see is what you get.");
----

Either of which gets you this:
[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  --help    What you see is what you get.
----

Another related command is cli.helpNoArgs(), which internally adds "--help" to
otherwise empty command lines.
[source, C++, test repl 2 2]
----
cli.helpNoArgs();
cli.helpOpt().desc("What you see is what you get.");
----

Now all there is, is help:
[source, shell session]
----
$ a.out
Usage: a.out [OPTIONS]

Options:
  --help    What you see is what you get.

$ a.out --help
Usage: a.out [OPTIONS]

Options:
  --help    What you see is what you get.
----

cli.helpOpt() writes to cli.conout(), which defaults to cout, but can be
changed via cli.iostreams().


=== Final Option
An option or operand can be marked so that all following arguments are treated
as positional operands, the same as when <<#special-arguments, "--">> is used.

This can be used to forward raw arguments to such things as another program or
an internal script language interpreter.

This example conditionally launches a child copy of itself with arbitrary
arguments.

[source, C++]
----
#include <cstdlib>  // system(...)

int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & say = cli.optVec<string>("say").desc("Something to say.");
    auto & sys = cli.opt<bool>("do").finalOpt().desc("Do something.");
    auto & args = cli.optVec<string>("[PROGRAM_AND_ARGUMENTS]")
        .desc("Complicated thing to do.");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    for (auto&& val : *say)
        cout << val << ' ';
    if (*sys) {
        cout.flush();
        system(cli.toCmdline(*args).c_str());
    }
    return EX_OK;
}
----

The sys variable could also have been defined as:

[source, C++, test alt, test repl 5 1]
----
    auto & sys = cli.opt<bool>("do!").desc("Do something.");
----

Let's try it out.

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS] [PROGRAM_AND_ARGUMENTS...]
  PROGRAM_AND_ARGUMENTS  Complicated thing to do.

Options:
  --do / --no-do  Do something.
  --say=STRING    Something to say.

  --help          Show this message and exit.

$ # Say "1" and "2" and launch child to say "three".
$ a.out --say 1 --say 2 --do a.out --say three
1 2 three
----


=== Choice
Sometimes you want an option to have a fixed set of possible values, such as
for an enum. You use opt.choice() to add legal choices, one at a time, to an
option.

Choices are similar to <<#flag-values, flag values>> but instead of
multiple boolean options populating a single variable it is a single
non-boolean option setting its variable to one of multiple values.

[source, C++]
----
enum class State { go, wait, stop };

int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & state = cli.opt<State>("streetlight", State::wait)
        .desc("Color of street light.").valueDesc("COLOR")
        .choice(State::go, "green", "Means go!")
        .choice(State::wait, "yellow", "Means wait, even if you're late.")
        .choice(State::stop, "red", "Means stop.");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    switch (*state) {
        case State::stop: cout << "STOP!"; break;
        case State::go: cout << "Go!"; break;
        case State::wait: cout << "Wait"; break;
    }
    return EX_OK;
}
----

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  --streetlight=COLOR  Color of street light.
      green   Means go!
      yellow  Means wait, even if you're late. (default)
      red     Means stop.

  --help               Show this message and exit.

$ a.out
Wait
$ a.out --streetlight
Error: No value given for --streetlight
$ a.out --streetlight=purple
Error: Invalid '--streetlight' value: purple
Must be 'green', 'yellow', or 'red'.
$ a.out --streetlight=green
Go!
----


=== Require
A simple way to make sure an option is specified is to mark it required with
opt.require(). This adds an after action that fails if no explicit value was
set for the option.

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & file = cli.opt<string>("file f").require();
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "Selected file: " << *file << endl;
    return EX_OK;
}
----

What you get:
[source, shell session]
----
$ a.out
Error: No value given for --file
$ a.out -ffile.txt
Selected file: file.txt
----

The error message references the first name in the list so if you flip it
around...
[source, C++, test repl 2 1]
----
auto & file = cli.opt<string>("f file").require();
----

\... it will complain about '-f' instead of '--file'.
[source, shell session]
----
$ a.out
Error: No value given for -f
----


=== Range and Clamp
When you want to limit a value to be within a range (inclusive) you can use
opt.range() to error out or opt.clamp() to convert values outside the range to
be equal to the nearest of the two edges.

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & count = cli.opt<int>("<COUNT>").clamp(1, 10);
    auto & letter = cli.opt<char>("<LETTER>").range('a','z');
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << string(*count, *letter) << endl;
    return EX_OK;
}
----

[source, shell session]
----
$ a.out 1000 b
bbbbbbbbbb
$ a.out 1000 1
Error: Out of range 'LETTER' value: 1
Must be between 'a' and 'z'.
----


=== Units of Measure
The opt.siUnits(), opt.timeUnits(), and opt.anyUnits() are implemented as
parser actions and provide a way to support unit suffixes on numerical values.
The value has the units removed, is parsed as a double, multiplied by the
associated factor, rounded to an integer (unless the target is a floating point
type), converted back to a string, and then finally passed to
opt.fromString&lt;T>().

The behavior can be customized with the following flags:

[%autowidth]
|===
| Flag | Description

| fUnitBinaryPrefix
| Only for opt.siUnits(), makes k,M,G,T,P factors of 1024 (just like
ki,Mi,Gi,Ti,Pi), and excludes fractional unit prefixes (milli, micro, etc).
| fUnitInsensitive
| Makes units case insensitive. For opt.siUnits(), unit prefixes are also case
insensitive and fractional unit prefixes are excluded. So 'M' and 'm' are both
mega.
| fUnitRequire
| Values without units are rejected, even if they have unit prefixes
(k,M,G,etc).
|===

==== SI Units
SI units are considered to be anything that uses the SI prefixes. The
supported prefixes range from 1e+15 to 1e-15 and are: P, Pi, T, Ti, G, Gi, M,
Mi, k, ki, m, u, n, p, f.

The following table shows the effects of the above flags (BP, I, R) and
whether a symbol (such as "m") is specified on the parsing of some
representative inputs:

[role=scrollable-x]
--

[cols=13*, role=smaller-td-font]
|===
.2+^.<h| Input
12+^h| Flags
h| -       h| +I       h| +BP       h| +BP,I
h| "m"     h| "m" +I   h| "m" +BP   h| "m" +BP,I
h| "m" +R  h| "m" +I,R h| "m" +BP,R h| "m" +BP,I,R

| "1M"
| 1e+6      | 1e+6      | 1,048,576  | 1,048,576
| 1e+6      | 1         | 1,048,576  | 1
| -         | 1         | -          | 1

| "1k"
| 1,000     | 1,000     | 1,024      | 1,024
| 1,000     | 1,000     | 1,024      | 1,024
| -         | -         | -          | -

| "1ki"
| 1,024     | 1,024     | 1,024      | 1,024
| 1,024     | 1,024     | 1,024      | 1,024
| -         | -         | -          | -

| "k"
| -         | -         | -          | -
| -         | -         | -          | -
| -         | -         | -          | -

| "1"
| 1         | 1         | 1          | 1
| 1         | 1         | 1          | 1
| -         | -         | -          | -

| "1m"
| 0.001     | 1e+6      | -          | 1,048,576
| 1         | 1         | 1          | 1
| 1         | 1         | 1          | 1

| "1u"
| 0.000001  | -         | -          | -
| -         | -         | -          | -
| -         | -         | -          | -

| "1Mm"
| -         | -         | -          | -
| 1e+6      | 1e+6      | 1,048,576  | 1,048,576
| 1e+6      | 1e+6      | 1,048,576  | 1,048,576

| "1km"
| -         | -         | -          | -
| 1,000     | 1,000     | 1,024      | 1,024
| 1,000     | 1,000     | 1,024      | 1,024

| "1kim"
| -         | -         | -          | -
| 1,024     | 1,024     | 1,024      | 1,024
| 1,024     | 1,024     | 1,024      | 1,024

| "km"
| -         | -         | -          | -
| -         | -         | -          | -
| -         | -         | -          | -

| "1mm"
| -         | -         | -          | -
| 0.001     | 1e+6      | -          | -
| 0.001     | 1e+6      | -          | -

|===

--

An example with binary prefixes that is case insensitive:
[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & bytes = cli.opt<uint64_t>("b bytes")
        .siUnits("b", cli.fUnitBinaryPrefix | cli.fUnitInsensitive)
        .desc("Number of bytes to process.");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    if (bytes)
        cout << *bytes << " bytes\n";
    return EX_OK;
}
----

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  -b, --bytes=NUM[<units>]  Number of bytes to process. (default: 0)

  --help                    Show this message and exit.

$ a.out -b 32768
32768 bytes
$ a.out -b 32k
32768 bytes
$ a.out -b 32KB
32768 bytes
$ a.out -b 32kib
32768 bytes
$ a.out -b 32bk
Error: Invalid '-b' value: 32bk
Units symbol 'bk' not recognized.
----

==== Time Units
Adjusts the value to seconds when time units are present. The following units
are supported:

[%autowidth]
|===
| Input | Factor

| y     | 31,536,000 (365 days, leap years not considered)
| w     | 604,800 (7 days)
| d     | 86,400 (24 hours)
| h     | 3,600
| m     | 60
| min   | 60
| s     | 1
| ms    | 0.001
| us    | 0.000001
| ns    | 0.000000001
|===

Interval in seconds where units are required:
[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & interval = cli.opt<uint32_t>("i interval")
        .timeUnits(cli.fUnitRequire)
        .desc("Time interval");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    if (interval)
        cout << *interval << " seconds\n";
    return EX_OK;
}
----

[source, shell session]
----
$ # Rounded to integer value so it can be stored in uint32_t
$ a.out -i 2100ms
2 seconds
$ # One year
$ a.out -i 1y
31536000 seconds
$ # You can only fit 136.2 years worth of seconds into uint32_t
$ a.out -i 137y
Error: Out of range '-i' value: 137y
Must be between '0' and '4,294,967,295'.
$ # We set fUnitRequire, so units are required...
$ a.out -i 60
Error: Invalid '-i' value: 60
Value requires suffix specifying the units.
----

==== Any Units
Allows any arbitrary set of unit+factor pairs, used by both opt.siUnits() and
opt.timeUnits().

Accept length in Imperial Units:
[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & length = cli.opt<double>("l length")
        .anyUnits({{"yd", 36}, {"ft", 12}, {"in", 1}, {"mil", 0.001}})
        .desc("Length, in inches");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    if (length)
        cout << *length << " inches\n";
    return EX_OK;
}
----

[source, shell session]
----
$ a.out
$ a.out -l 1yd
36 inches
$ a.out -l 3ft
36 inches
$ a.out -l 36
36 inches
----


=== Counting
In very rare circumstances, it might be useful to use repetition to increase
an integer. There is no special handling for it, but counting can be done
easily enough with a vector. This can be used for verbosity flags, for
instance:

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & v = cli.optVec<bool>("v verbose");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "Verbosity: " << v.size();
    return EX_OK;
}
----
And on the command line:

[source, shell session]
----
$ a.out -vvv
Verbosity: 3
----

This could also be done with a <<#parse-actions, parse action>>, but that seems
like more work.


=== Prompting
You can have an option prompt the user for the value when it's left off of
the command line.

In addition to simple prompting, there are some flags that modify the behavior.

[%autowidth]
|===
| Flag             | Description

| fPromptHide      | Hide the input from the console
| fPromptConfirm   | Require the value be entered twice
| fPromptNoDefault | Don't show the default
|===

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & cookies = cli.opt<int>("cookies c").prompt();
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "There are " << *cookies << " cookies.";
    return EX_OK;
}
----
By default the prompt is a capitalized version of the first option name.
Which is why this example uses "cookies c" instead of "c cookies".

[source, shell session, test getline 3 -1]
----
$ a.out -c5
There are 5 cookies.
$ a.out
Cookies [0]: 3
There are 3 cookies.
----
The first option name is also used in errors where no name is available from
the command line, such as when the value is from a prompt. The following
fails because "nine" isn't an int.

[source, shell session, test getline 1 -4]
----
$ a.out
Cookies [0]: nine
Error: Invalid '--cookies' value: nine
----
You can change the prompt to something more appropriate and hide the default:

[source, C++, test repl 2 1]
----
auto & cookies = cli.opt<int>("cookies c")
    .prompt("How many cookies did you buy?", cli.fPromptNoDefault);
----
Which gives you:

[source, shell session, test getline 1 -1]
----
$ a.out
How many cookies did you buy? 9
There are 9 cookies.
----


=== Password Prompting
The fPromptHide and fPromptConfirm options are especially handy when asking
for passwords.

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    auto & pass = cli.opt<string>("password")
        .prompt(cli.fPromptHide | cli.fPromptConfirm);
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "Password was: " << *pass;
    return EX_OK;
}
----
Results in:

[source, shell session]
----
$ (echo secret & echo secret) | a.out
Password:
Enter again to confirm:
Password was: secret
----
For passwords you can use opt.passwordOpt() instead of spelling it out.

[source, C++, test repl 2 2]
----
auto & pass = cli.passwordOpt(/*confirm=*/true);
----
Which gives you:

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  --password=STRING  Password required for access.

  --help             Show this message and exit.
----


=== Confirm Option
There is a short cut for a "-y, --yes" option, called cli.confirmOpt(), that
only lets the program run if the option is set or the user responds with 'y'
or 'Y' when asked if they are sure. Otherwise it sets cli.exitCode() to EX_OK
and causes cli.parse() to return false.

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    cli.confirmOpt();
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    cout << "HELLO!!!";
    return EX_OK;
}
----
Cover your ears...

[source, shell session, test getline 11 -1, test getline 13 -1]
----
$ a.out --help
Usage: a.out [OPTIONS]

Options:
  -y, --yes  Suppress prompting to allow execution.

  --help     Show this message and exit.

$ a.out -y
HELLO!!!
$ a.out
Are you sure? [y/N]: n
$ a.out
Are you sure? [y/N]: y
HELLO!!!
----
You can change the prompt:

[source, C++, test repl 2 1]
----
cli.confirmOpt("Are loud noises okay?");
----
Now it asks:

[source, shell session, test getline 1 -1]
----
$ a.out
Are loud noises okay? [y/N]: y
HELLO!!!
----


== Help Text

=== Page Layout
The main help page, and the help pages for subcommands, are built the same way
and made up of the same seven (not counting <<#option-groups, option groups>>)
sections.

[%autowidth]
|===
| Section     | Changed by | Description

| Header
| cli.header()
| Generally a one line synopsis of the purpose of the command.

| Usage
| cli.opt()
| Command usage listing the defined options and operands.

| Description
| cli.desc()
| Text describing how to use the command and what it does. Sometimes used
instead of the operands list.

| Commands
| cli.command(), cli.desc(), opt.command()
| List of commands and first line of their description, included if there are
any git style subcommands.

| Operands
| cli.opt(), opt.desc(), opt.nameDesc()
| List of operands and their descriptions, omitted if none have
descriptions.

| Options
| cli.opt(), opt.desc(), opt.nameDesc(), opt.valueDesc(), opt.defaultDesc(),
opt.show()
| List of named options and descriptions, included if there are any visible
options.

| Footer
| cli.footer()
| Shown at the end, often contains references to further information.

|===

Within text, consecutive spaces are collapsed and words are wrapped (at 80
columns by default). Newlines should be reserved for paragraph breaks.

[source, C++]
////
int main(int argc, char * argv[]) {
    #error <place holder>
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    return EX_OK;
}
////

[source, C++, test repl 1 1]
----
Dim::Cli cli;
cli.header("Heading before usage");
cli.desc("Description of what the command does, including any general "
    "discussion of the various aspects of its use.");
cli.opt<bool>("[OPERAND]");
cli.opt<string>("option").valueDesc("OPT_VAL").desc("About this option.");
cli.opt<long long>("p", 1).valueDesc("NUM64").desc("Option p.");
cli.opt<int>("q", 2).desc("Option q.").defaultDesc("two, yes TWO!");
cli.opt<int>("r", 3).desc("Option r.").defaultDesc("");
auto & lvl = cli.opt<int>("1", 1).flagValue(true)
    .nameDesc("-1, -2, -3").desc("Set the level from 1 to 3.")
    .defaultDesc("");
cli.opt(lvl, "2", 2).flagValue().show(false);
cli.opt(lvl, "3", 3).flagValue().show(false);
cli.footer(
    "Footer at end, usually with where to find more info.\n"
    "- first reference\n"
    "- second reference\n"
);
----

In this example the operands section is omitted because the operand doesn't
have a description.

[source, shell session]
----
$ a.out --help
Heading before usage
Usage: a.out [OPTIONS] [OPERAND]

Description of what the command does, including any general discussion of the
various aspects of its use.

Options:
  -1, -2, -3        Set the level from 1 to 3.
  --option=OPT_VAL  About this option.
  -p NUM64          Option p. (default: 1)
  -q NUM            Option q. (default: two, yes TWO!)
  -r NUM            Option r.

  --help            Show this message and exit.

Footer at end, usually with where to find more info.
- first reference
- second reference
----

==== Value description
Value descriptions like OPT_VAL and NUM64 can be changed per option as shown
above, but you can also change the default for a type by specializing
Cli::valueDesc&lt;>(). For example, we can change the default for "long long"
instead of explicitly overriding it for -p.

Add the specialization:

[source, C++, test repl 0 0]
----
template <>
inline string Dim::Cli::valueDesc<long long>() {
    return "NUM64";
}

----

And remove the call to opt.valueDesc() from the "p" option:

[source, C++, test repl 12 1]
----
cli.opt<long long>("p", 1).desc("Option p.");
----

The help text will be the same.

[source, shell session, test repl 0 1]
////
$ a.out --help
////
++++
++++


=== Option Groups
Option groups are used to collect related options together in the help text. In
addition to name, groups have a title and sort key that determine section
heading and the order groups are rendered. Groups are created on first
reference, with the title and sort key initialized to the same value as the
name.

Additionally there are two predefined option groups:

[%autowidth]
|===
| Name | Sort | Title | Description

| ""   | ""   | "Options"
| Default group when options are created.

| "~"  | "~"  | ""
| Footer group, default location for "--help" and "--version".

|===

In order to generate the help text, the visible options are collected into
groups, the groups are sorted by sort key, and the options within each group
are sorted by name.

The group title followed by the options is then output for each group that
has options. A group without a title is still separate from the previous group
by a single blank line.

To group options you either use opt.group() to set the group name or create
the option using cli.opt&lt;T>() after changing the context with cli.group().

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    cli.versionOpt("1.0");
    // Move 1b into 'First' group after creation.
    cli.opt<bool>("1b.").group("First").desc("boolean 1b");
    // Set context to 'First' group, update its key and add 1a directly to it.
    cli.group("First").sortKey("a").title(
        "First has a really long title that wraps around to more than "
        "a single line, quite a lot of text for so few options"
    );
    cli.opt<bool>("1a.");
    // Add 2a to 'Second' and 3a to 'Third'.
    cli.group("Second").sortKey("b").opt<bool>("2a.");
    cli.group("Third").sortKey("c").opt<bool>("3a.");
    // Give the footer group a title.
    cli.group("~").title("Internally Generated");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    return EX_OK;
}
----
Let's see the groupings...

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS]

First has a really long title that wraps around to more than a single line,
quite a lot of text for so few options:
  --1a
  --1b       boolean 1b

Second:
  --2a

Third:
  --3a

Internally Generated:
  --help     Show this message and exit.
  --version  Show version and exit.
----


=== Command Groups
Command groups collect related commands together in the help text, in the same
way that option groups do with options.

There are two predefined command groups:

[%autowidth, cols=4*]
|===
| Name | Sort | Title | Description

| ""   | ""   | "Commands"
| Default command group

| "~"  | "~"  | ""
| Footer group, default location for "help"

|===

To group commands you either use cli.cmdGroup() to set the group name or create
the command using cli.command() from the context of another command that is
already in the command group that you want for the new command.

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;

    // Move 1a into 'First' group after creation.
    cli.command("1a").cmdGroup("First").cmdSortKey("1");
    // Create 1b in current 'First' group.
    cli.command("1b");
    // Create 2a and move it into 'Second'.
    cli.command("2a").cmdGroup("Second").cmdSortKey("2");
    // Create 3a and move to 'Third'.
    cli.command("3a").cmdGroup("Third").cmdSortKey("3");
    if (!cli.parse(argc, argv))
        return cli.printError(cerr);
    return EX_OK;
}
----
Let's see the command groupings...

[source, shell session]
----
$ a.out --help
Usage: a.out [OPTIONS] COMMAND [ARGS...]

First:
  1a
  1b

Second:
  2a

Third:
  3a

Options:
  --help    Show this message and exit.
----


=== Help Subcommand
A simple help command can be added via cli.helpCmd(). Having a help command
allows users to run the more natural "a.out help command" to get help with a
subcommand instead of the more annoying "a.out command --help".

Like cli.<<#help-option, helpOpt>>(), cli.helpCmd() writes to cli.conout(),
which defaults to cout and can be changed via cli.iostreams().

How to add it:
[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    cli.helpCmd();
    cli.exec(argc, argv);
    return cli.printError(cerr);
}
----

Programs that only have a simple help command aren't very helpful, but it
should give you an idea. If you have more commands they will show up as you'd
expect.
[source, shell session]
----
$ a.out help
Usage: a.out [OPTIONS] COMMAND [ARGS...]

Commands:
  help      Show help for individual commands and exit.

Options:
  --help    Show this message and exit.

$ a.out help help
Usage: a.out help [OPTIONS] [COMMAND]

Show help for individual commands and exit. If no command is given the list of
commands and general options are shown.
  COMMAND   Command to show help information about.

Options:
  -u, --usage / --no-usage  Only show condensed usage.

  --help                    Show this message and exit.

$ a.out help -u
Usage: a.out [--help] COMMAND [ARGS...]

$ a.out help help -u
Usage: a.out help [-u, --usage] [--help] [COMMAND]
----


=== Going Your Own Way
If generated help doesn't work for you, you can override the built-in help
with your own.

[source, C++]
----
auto & help = cli.opt<bool>("help"); // or maybe "help." to suppress --no-help
if (!cli.parse(argc, argv))
    return cli.printError(cerr);
if (*help)
    return printMyHelp();
----

This works because the last definition for named options overrides any
previous ones.

Within your help printer you can use the existing functions to do some of the
work:

* cli.printHelp
* cli.printUsage / cli.printUsageEx
* cli.printOperands
* cli.printOptions
* cli.printCommands
* cli.printText


== Arbitrary Text
The cli.printText() function is used to word wrap paragraphs and columnize
simple tables. The text is split on '\n' into lines, and each line is processed
as either a paragraph (if there are no '\t' chars separating it into columns)
or table row (if there are '\t' chars). Formatting is modified by embedding
special characters in the text.

[%autowidth, cols="^,<"]
|===
2+<h| Separators
| \n | Paragraph or table row separator.
| \t | Table column separator.
|===

=== Paragraphs
A paragraph consists of a preamble followed by the body. The preamble contains
any number of the following and ends at the first character that is something
else:

[%autowidth, cols="^,<"]
|===
2+<h| Preamble
| \r | Decrease indent of wrapped text.
| \v | Increase indent of wrapped text.
| SP | Increase indent of paragraph or column text.
|===

[source, C++]
----
int main(int argc, char * argv[]) {
    Dim::Cli cli;
    cli.maxWidth(50); // These examples assume console width of 50.
    cli.printText(cout,
        "Default paragraph wrapped at column 50 with default indentation.\n"
        "  \r\rIndented paragraph with all following lines unindented.\n"
        "\v\vParagraph with all lines but the very first indented.\n"
    );
    return EX_OK;
}
----

[source, shell session]
----
$ a.out
Default paragraph wrapped at column 50 with
default indentation.
  Indented paragraph with all following lines
unindented.
Paragraph with all lines but the very first
  indented.
----

The body of a paragraph consists of space separated tokens (consecutive spaces
are treated as one). Line breaks are added between tokens as needed. The
following characters have special meaning:

[%autowidth, cols="^,<"]
|===
2+<h| Body
| \b | Non-breaking space.
|===

[source, C++, test repl 4 3]
----
"The quick brown fox jumped underneath the lazy dog.\n"
"The quick brown fox jumped underneath the lazy\bdog.\n"
----

[source, shell session, test repl 1]
----
The quick brown fox jumped underneath the lazy
dog.
The quick brown fox jumped underneath the
lazy dog.
----

=== Tables
All lines containing one or more '\t' characters are table rows. Tables are
made up of rows grouped by the first column indent and then split by those with
the '\f' (new table) flag. Columns are just additional paragraphs with larger
indentation. In other words, column width is only used to find the starting
position of the next column.

In addition to what's allowed in paragraph preambles, a column preamble may
also include the following phrases:

[%autowidth, cols="^,<"]
|===
2+<h|Preamble

| \a<MIN>{nbsp}<MAX>\a
| Set min and max widths of a table column, where MIN and MAX are percentages
of console width encoded as floats. Only in columns of a row that is marked
with '\f' (new table).

| \f
| Start of new table, allowed in preamble of any or all columns.
|===

Tables can be interleaved.

[source, C++, test repl 4 2]
----
"Table A, Row I\tThe 0 indent table\n"
"  Table B, Row I\tFirst 2 indent table\n"
"Table A, Row II\tThe 0 indent table\n"
"  \fTable C, Row I\tNew 2 indent table (because\bof\b\\f)\n"
----

[source, shell session, test repl 1]
----
Table A, Row I   The 0 indent table
  Table B, Row I  First 2 indent table
Table A, Row II  The 0 indent table
  Table C, Row I  New 2 indent table
                  (because of \f)
----

Text never wraps until the end of the console window.

[source, C++, test repl 4 4]
----
"This is first column text that extends to the following line.\t"
"Second column, also with enough text to wrap all the way around.\t"
"Third and final column, also wrapping.\n"
----

[source, shell session, test repl 1]
----
This is first column text that extends to the
following line.
          Second column, also with enough text to
          wrap all the way around.
                    Third and final column, also
                    wrapping.
----

Column width is calculated by finding the longest text of any cell in that
column of the table that doesn't exceed the column's max width with a minimum
of the min width. Default min/max column width is 15%/38% for the first and
15%/15% for the rest. The default for the first column can be changed with
cli.maxWidth().

[source, C++, test repl 4 3]
----
"\f\a10 10\aone\tSet column width to 5 (10% of 50).\n"
"four\tThere is always at least a two space gap between columns.\n"
"fourteen\tToo long for column width, pushed down.\n"
----

[source, shell session, test repl 1]
----
one  Set column width to 5 (10% of 50).
four  There is always at least a two space gap
     between columns.
fourteen
     Too long for column width, pushed down.
----
