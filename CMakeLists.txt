# CMakeLists.txt - general project generator
#
# Copyright Glen Knowles 2016 - 2017.
# Distributed under the Boost Software License, Version 1.0.
#
# Required project layout:
#   /<project_name>
#   /<project_name>/CMakeLists.txt - this file
#   /<project_name>/CMakeDeps.cmake - made by this file (source controlled)
#   /<project_name>/libs/<lib_project_name>/**
#   /<project_name>/libs/${PROJECT_NAME}/config.h
#       has special transformation
#   /<project_name>/tests/<test_project_name>/
#   /<project_name>/tools/<tool_project_name>/
#   /<project_name>/vendor/<vendor_project_name>/
#       if /<project_name>/vendor/<vendor_project_name>/CMakeLists.txt exists

cmake_minimum_required (VERSION 3.6)
set_property(GLOBAL PROPERTY USE_FOLDERS ON)
option(LINK_STATIC_RUNTIME "Link with static c++ runtime" ON)
option(BUILD_SHARED_LIBS "Build DLLs instead of static libs" OFF)

# For internal use by this script
option(RECURSIVE_GENERATE "Recursive call to cmake" OFF)

# Reference to suppress "not used" warning when manually specified
# by vcpkg
set(tmp "${CMAKE_BUILD_TYPE}")


#############################################################################
#
#   Functions
#
####

# Compare the new contents with the existing file, if it exists and is the 
# same we don't want to trigger a make by changing its timestamp.
function(update_file path content)
    set(old_content "")
    if(EXISTS "${path}")
        file(READ "${path}" old_content)
    endif()
    if(NOT old_content STREQUAL content)
        file(WRITE "${path}" "${content}")
    endif()
endfunction()

# Creates a file called CMakeDeps.cmake next to the CMakeLists.txt with
# the list of dependencies in it - this file should be treated as part of 
# CMakeLists.txt (source controlled, etc.).
function(update_deps_file)
    set(deps_file "CMakeDeps.cmake")
    # Normalize the list so it's the same on every machine
    foreach(dep ${ARGV})
        get_filename_component(dep "${dep}" ABSOLUTE)
        file(RELATIVE_PATH rel_dep ${CMAKE_CURRENT_SOURCE_DIR} ${dep})
        list(APPEND rel_deps ${rel_dep})
    endforeach()
    list(REMOVE_DUPLICATES rel_deps)
    list(SORT rel_deps)
    # Build the content
    set(content "# generated by make process\n")
    foreach(dep IN LISTS rel_deps)
        string(APPEND content "# ${dep}\n")
    endforeach()
    # Update the deps file
    update_file("${deps_file}" "${content}")
    # Include the file so it's tracked as a generation dependency; we don't
    # need the content.
    include(${deps_file})
endfunction()

function(write_user_file prjname)
    set(user_file "${CMAKE_CURRENT_BINARY_DIR}/${prjname}.vcxproj.user")
    file(WRITE ${user_file} [=[
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" 
        xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
]=])
    foreach(cfgname ${CMAKE_CONFIGURATION_TYPES})
        if(${cfgname} STREQUAL Release)
            set(libpath "lib")
        else()
            set(libpath "${cfgname}/lib")
        endif()
        file(APPEND ${user_file} [=[
    <PropertyGroup Condition="'$(Configuration)|$(Platform)'==']=] "${cfgname}" [=[|x64'">
        <LocalDebuggerWorkingDirectory>$(TargetDir)</LocalDebuggerWorkingDirectory>
        <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
        <VcpkgLibPath>]=] "${libpath}" [=[</VcpkgLibPath>
    </PropertyGroup>
]=])
    endforeach()
    file(APPEND ${user_file} [=[
</Project>
]=])
endfunction()

function(install_archive_pdb tgt dstdir)
    if(BUILD_SHARED_LIBS)
        install(FILES "$<TARGET_PDB_FILE:${tgt}>" DESTINATION bin)
    else()
        # Special handling required to get PDBs of static libraries installed.
        # I would hope that there's a better way to do this, but I don't know 
        # what it may be...
        foreach(cfg ${CMAKE_CONFIGURATION_TYPES})
            install(FILES 
                "${CMAKE_CURRENT_BINARY_DIR}/${tgt}.dir/${cfg}/${tgt}.pdb" 
                DESTINATION ${dstdir} 
                CONFIGURATIONS ${cfg})
        endforeach()
    endif()
endfunction()

function(add_exec_project tgt srcdir)
    if(MSVC)
        set_property(SOURCE "${srcdir}/pch.cpp" 
            APPEND PROPERTY COMPILE_FLAGS "/Ycpch.h")
    endif()
    file(GLOB_RECURSE sources LIST_DIRECTORIES false ${srcdir}/*.h ${srcdir}/*.cpp)
    list(APPEND deps ${sources})
    set(deps ${deps} PARENT_SCOPE)
    add_executable(${tgt} ${sources})
	if(MSVC)
		set_target_properties(${tgt} PROPERTIES LINK_FLAGS /Debug)
	endif()
    foreach(var ${libnames})
        get_filename_component(libname "${var}" NAME)
        target_link_libraries(${tgt} ${libname})
    endforeach()
	if(CMAKE_COMPILER_IS_GNUCXX)
        # required for #include <experimental/filesystem>
		target_link_libraries(${tgt} "stdc++fs")
    elseif(CMAKE_CXX_COMPILER_ID STREQUAL Clang)
		target_link_libraries(${tgt} "stdc++fs")
    endif()
    source_group("" FILES ${sources})
    write_user_file(${tgt})
endfunction()

function(add_lib_project tgt srcdir)
    if(MSVC)
        set_property(SOURCE "${srcdir}/pch.cpp" 
            APPEND PROPERTY COMPILE_FLAGS "/Ycpch.h")
    endif()
    file(GLOB_RECURSE sources LIST_DIRECTORIES false ${srcdir}/*)
    list(APPEND deps ${sources})
    set(deps ${deps} PARENT_SCOPE)
    set(cpps ${sources})
    list(FILTER cpps INCLUDE REGEX ".*\.cpp$")
    list(LENGTH cpps cpps)
    if(cpps)
        add_library(${tgt} ${sources})
        target_compile_definitions(${tgt} PRIVATE DIM_LIB_SOURCE)
        list(APPEND libnames ${tgt})
        set(libnames ${libnames} PARENT_SCOPE)

        install(TARGETS ${tgt}
            ARCHIVE DESTINATION lib
            RUNTIME DESTINATION bin)
        install_archive_pdb(${tgt} lib)
    else()
        add_custom_target(${tgt} SOURCES ${sources})
    endif()
    file(GLOB incls LIST_DIRECTORIES false 
        RELATIVE "${srcdir}" "${srcdir}/*.h")
    foreach(var ${incls})
        get_filename_component(name "${var}" NAME)
        if(NOT name MATCHES ".*int\.h")
            install(FILES "${srcdir}/${var}" DESTINATION include/${tgt})
        endif()
    endforeach()
    set_target_properties(${tgt} PROPERTIES FOLDER libs)
    if(NOT EXISTS "${srcdir}/pch.h")
        if(MSVC)
            set_property(TARGET ${tgt} APPEND PROPERTY COMPILE_FLAGS "/Y-")
        endif()
    endif()
    source_group("" FILES ${sources})
    write_user_file(${tgt})
endfunction()


#############################################################################
#
#   Main
#
####

# get name of project from containing directory
get_filename_component(prjname "${CMAKE_CURRENT_SOURCE_DIR}" NAME)
project(${prjname})

get_property(parent DIRECTORY PROPERTY PARENT_DIRECTORY)
if("${parent}" STREQUAL "")
    set(ROOT_PROJECT true)
endif()

# In order to make a copy of the solution at the source root (where it's 
# required to be for the git integration) we need to copy - and tweak -
# the it post generation. But cmake doesn't allow for post generation hooks,
# so we launch another instance of cmake and do transform and copy after it
# returns. After that we do the generation (again), potentially followed by
# build and/or install.
if(ROOT_PROJECT AND NOT RECURSIVE_GENERATE)
    message(STATUS "Recursive generate started")
    execute_process(
        COMMAND ${CMAKE_COMMAND} 
            -DRECURSIVE_GENERATE:BOOL=ON 
            -DLINK_STATIC_RUNTIME:BOOL=${LINK_STATIC_RUNTIME}
            -DBUILD_SHARED_LIBS:BOOL=${BUILD_SHARED_LIBS}
            ${CMAKE_SOURCE_DIR}
    )
    message(STATUS "Recursive generate done")

    set(sln_binpath ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.sln)
    if(EXISTS ${sln_binpath})
        # Load solution file from bin-dir and change the relative references 
        # to project files so that the in memory copy is as if it had been 
        # built in the source dir.
        file(RELATIVE_PATH prefix 
            "${CMAKE_CURRENT_SOURCE_DIR}"
            "${CMAKE_CURRENT_BINARY_DIR}")
        file(READ ${sln_binpath} sln_content)
        string(REGEX REPLACE 
            "\"([^\"]+).vcxproj\""
            "\"${prefix}/\\1.vcxproj\"" 
            sln_content
            "${sln_content}")

        # Compare the updated contents with the existing source path sln, if it
        # exists and is the same we don't want to disturb VS by touching it.
        set(sln_srcpath ${CMAKE_CURRENT_SOURCE_DIR}/${PROJECT_NAME}.sln)
        update_file("${sln_srcpath}" "${sln_content}")
    endif()
endif()

set(CMAKE_CONFIGURATION_TYPES Debug Release)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE ${CMAKE_BINARY_DIR}/bin)

if(NOT ROOT_PROJECT)
    set_property(DIRECTORY "${parent}" APPEND PROPERTY INCLUDE_DIRECTORIES 
        "${CMAKE_CURRENT_SOURCE_DIR}/libs")
endif()
include_directories(libs)

if(MSVC)
    # "/utf-8" - sets source code character set to utf-8
    # "/W4" - warning level 4
    # "/WX" - treat warnings as errors
    # "/Zi" - debug info format - defaults to no info
    # "/Yupch.h" - use pch.h as precompiled header 
    # "/std:c++latest" - allow constructs still pending standardization
    # "/Zc:inline" - all inline functions must have definition available
    # "/Zc:rvalueCast" - enforce type conversion rules
    # "/Zc:strictStrings" - disable string literal type conversion to non-const
    # "/GR-" (UNUSED) - disable RTTI
    # "/EHsc" - exceptions from c++ only (not from structure or "C")
    # "/GF" - string pooling
    set(CMAKE_CXX_FLAGS "\
        /utf-8 /W4 /WX /Zi /Yupch.h \
        /std:c++latest /Zc:inline /Zc:rvalueCast /Zc:strictStrings \
        /EHsc /GF")
    if(NOT MSVC_VERSION LESS 2000)
        # /permissive-  // reject non-conforming backward compatibilitisms
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /permissive-")
    endif()

    # "/Od" - disables optimization
    # "/RTC1" - runtime checks (stack frame over/under run and uninit var use)
    set(CMAKE_CXX_FLAGS_DEBUG "/Od /RTC1")
    if(LINK_STATIC_RUNTIME)
        # "/MTd" - multithread debug static runtime
        set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /MTd")
    else()
        # "/MDd" - multithread debug dll runtime
        set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /MDd")
    endif()
    
    # "/O2" - maximize speed
    set(CMAKE_CXX_FLAGS_RELEASE "/DNDEBUG /O2")
    if(LINK_STATIC_RUNTIME)
        # "/MT" - multithread release static runtime
        set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /MT")
    else()
        # "/MD" - multithread release dll runtime
        set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /MD")
    endif()

    set_property(SOURCE "pch.cpp" APPEND PROPERTY COMPILE_FLAGS "/Ycpch.h")
elseif(CMAKE_CXX_COMPILER_ID STREQUAL Clang)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++1z")
endif()

# set list of defines that need to go in config.h
if(BUILD_SHARED_LIBS)
    list(APPEND config_defines DIM_LIB_DYN_LINK)
endif()
if(WINDOWS_STORE)
    list(APPEND config_defines DIM_LIB_WINAPI_FAMILY_APP)
endif()
foreach(var ${config_defines})
    add_definitions(/D${var})
endforeach()

set(deps, "")

# lib targets
file(GLOB allnames libs/*)
foreach(var ${allnames})
    if(IS_DIRECTORY "${var}")
        get_filename_component(prjname "${var}" NAME)
        if(NOT prjname STREQUAL ${PROJECT_NAME})
            set(prjname ${PROJECT_NAME}-${prjname})
        endif()
        add_lib_project(${prjname} "${var}")
    endif()
endforeach()

if(NOT ROOT_PROJECT)
    set(libnames ${libnames} PARENT_SCOPE)
    return()
endif()

# vendor dependencies
file(GLOB allnames vendor/*)
foreach(var ${allnames})
    if(IS_DIRECTORY "${var}")
        list(APPEND deps "${var}")
        get_filename_component(prjname "${var}" NAME)
        if(EXISTS "${var}/CMakeLists.txt")
            add_subdirectory("${var}")
        endif()
    endif()
endforeach()

# meta target
file(GLOB sources LIST_DIRECTORIES false 
    LICENSE
    .clang-format
    .travis.yml
    appveyor.yml
    *.md
    configure.bat
    docs/*)
list(APPEND deps ${sources})
add_custom_target("_meta" SOURCES ${sources})
set_target_properties(_meta PROPERTIES FOLDER config)
source_group("docs" REGULAR_EXPRESSION "docs/.*")
source_group("" FILES configure.bat)

# tool targets
file(GLOB allnames tools/*)
foreach(var ${allnames})
    if(IS_DIRECTORY "${var}")
        get_filename_component(prjname "${var}" NAME)
        add_exec_project(${prjname} "${var}")
        set_target_properties(${prjname} PROPERTIES FOLDER tools)
        # install(TARGETS ${prjname} RUNTIME DESTINATION bin)
    endif()
endforeach()

# test targets
enable_testing()
file(GLOB allnames tests/*)
foreach(var ${allnames})
    if(IS_DIRECTORY "${var}")
        get_filename_component(prjname "${var}" NAME)
        add_exec_project(${prjname} "${var}")
        set_target_properties(${prjname} PROPERTIES FOLDER tests)
        add_test(NAME ${prjname} COMMAND ${prjname})
    endif()
endforeach()

# update deps file
update_deps_file(${deps})

# Create modifed config.h to reflect build defines
set(cfgname "libs/${PROJECT_NAME}/config.h")
get_filename_component(path ${cfgname} ABSOLUTE)
if(EXISTS "${path}")
    file(READ "${path}" content)
    foreach(val ${config_defines})
        string(REGEX REPLACE 
            "\n//#define ${val}" "\n#define ${val}" 
            content "${content}")
    endforeach()
    update_file("${CMAKE_CURRENT_BINARY_DIR}/${cfgname}" "${content}")

    install(FILES "${CMAKE_CURRENT_BINARY_DIR}/${cfgname}" 
        DESTINATION include/${PROJECT_NAME})
endif()
