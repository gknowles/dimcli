# CMakeLists.txt - dim cli

cmake_minimum_required (VERSION 3.6)
project (dimcli)
set_property(GLOBAL PROPERTY USE_FOLDERS ON)
set(CMAKE_CONFIGURATION_TYPES Debug Release)
option(LINK_STATIC_RUNTIME "Link with static c++ runtime" ON)
option(BUILD_SHARED_LIBS "Build DLLs instead of static libs" OFF)

# Reference to suppress "not used" warning when manually specified
set(tmp "${CMAKE_BUILD_TYPE}")

# Compare the new contents with the existing file, if it exists and is the 
# same we don't want to trigger a make by changing its timestamp.
function(update_file path content)
    set(old_content "")
    if(EXISTS "${path}")
        file(READ "${path}" old_content)
    endif()
    if(NOT old_content STREQUAL content)
        file(WRITE "${path}" "${content}")
    endif()
endfunction()

# Creates a file called CMakeDeps.cmake next to the CMakeLists.txt with
# the list of dependencies in it - this file should be treated as part of 
# CMakeLists.txt (source controlled, etc.).
function(update_deps_file)
    set(deps_file "CMakeDeps.cmake")
    # Normalize the list so it's the same on every machine
    foreach(dep ${ARGV})
        get_filename_component(dep "${dep}" ABSOLUTE)
        file(RELATIVE_PATH rel_dep ${CMAKE_CURRENT_SOURCE_DIR} ${dep})
        list(APPEND rel_deps ${rel_dep})
    endforeach()
    list(REMOVE_DUPLICATES rel_deps)
    list(SORT rel_deps)
    # Build the content
    set(content "# generated by make process\n")
    foreach(dep IN LISTS rel_deps)
        string(APPEND content "# ${dep}\n")
    endforeach()
    # Update the deps file
    update_file("${deps_file}" "${content}")
    # Include the file so it's tracked as a generation dependency; we don't
    # need the content.
    include(${deps_file})
endfunction()

function(write_user_file prjname)
    set(user_file "${CMAKE_CURRENT_BINARY_DIR}/${prjname}.vcxproj.user")
    file(WRITE ${user_file} [=[
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" 
        xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
]=])
    foreach(cfgname ${CMAKE_CONFIGURATION_TYPES})
        file(APPEND ${user_file} [=[
    <PropertyGroup Condition="'$(Configuration)|$(Platform)'==']=] "${cfgname}" [=[|x64'">
        <LocalDebuggerWorkingDirectory>$(TargetDir)</LocalDebuggerWorkingDirectory>
        <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
    </PropertyGroup>
]=])
    endforeach()
    file(APPEND ${user_file} [=[
</Project>
]=])
endfunction()

include_directories(include)

if(MSVC)
    # "/utf-8" - sets source code character set to utf-8
    # "/W4" - warning level 4
    # "/WX" - treat warnings as errors
    # "/Zi" - debug info format - defaults to no info
    # "/Yupch.h" - use pch.h as precompiled header 
    # "/std:c++latest" - allow constructs still pending standardization
    # "/Zc:inline" - all inline functions must have definition available
    # "/Zc:rvalueCast" - enforce type conversion rules
    # "/Zc:strictStrings" - disable string literal type conversion to non-const
    # "/GR-" - disable RTTI
    # "/EHsc" (UNUSED) - exceptions from c++ only (not from structure or "C")
    # "/GF" - string pooling
    set(CMAKE_CXX_FLAGS "\
        /utf-8 /W4 /WX /Zi /Yupch.h \
        /std:c++latest /Zc:inline /Zc:rvalueCast /Zc:strictStrings \
        /GR- /GF")
    if(NOT MSVC_VERSION LESS 2000)
        # /permissive-  // reject non-conforming backward compatibilitisms
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /permissive-")
    endif()

    # "/Od" - disables optimization
    # "/RTC1" - runtime checks (stack frame over/under run and uninit var use)
    set(CMAKE_CXX_FLAGS_DEBUG "/Od /RTC1")
    if(LINK_STATIC_RUNTIME)
        # "/MTd" - multithread debug static runtime
        set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /MTd")
    else()
        # "/MDd" - multithread debug dll runtime
        set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /MDd")
    endif()
    
    # "/O2" - maximize speed
    set(CMAKE_CXX_FLAGS_RELEASE "/DNDEBUG /O2")
    if(LINK_STATIC_RUNTIME)
        # "/MT" - multithread release static runtime
        set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /MT")
    else()
        # "/MD" - multithread release dll runtime
        set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /MD")
    endif()

    set_property(SOURCE "pch.cpp" APPEND PROPERTY COMPILE_FLAGS "/Ycpch.h")
endif()

if(BUILD_SHARED_LIBS)
    add_definitions(/DDIM_LIB_DYN_LINK)
endif()

file(GLOB meta_sources LIST_DIRECTORIES false 
    LICENSE
    .clang-format
    .travis.yml
    appveyor.yml
    *.md
    configure.bat
    docs/*)
update_deps_file(${meta_sources})
add_custom_target("_meta" SOURCES ${meta_sources})
source_group("docs" REGULAR_EXPRESSION "docs/.*")
source_group("" FILES configure.bat)

enable_testing()
add_subdirectory(src)
add_subdirectory(test)

# The solution file isn't generated until after this script finishes, 
# which means that:
#   - it might not exist (if this is the first run)
#   - you need to run cmake twice to ensure any new solution was copied
set(sln_binpath ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.sln)
if(EXISTS ${sln_binpath})
    # Load solution file from bin-dir and change the relative references to 
    # project files so that the in memory copy is as if it had been built in 
    # the source dir.
    file(RELATIVE_PATH prefix 
        "${CMAKE_CURRENT_SOURCE_DIR}"
        "${CMAKE_CURRENT_BINARY_DIR}")
    file(READ ${sln_binpath} sln_content)
    string(REGEX REPLACE 
        "\"([^\"]+).vcxproj\""
        "\"${prefix}/\\1.vcxproj\"" 
        sln_content
        "${sln_content}")

    # Compare the updated contents with the existing source path sln, if it
    # exists and is the same we don't want to disturb VS by touching it.
    set(sln_srcpath ${CMAKE_CURRENT_SOURCE_DIR}/${PROJECT_NAME}.sln)
    update_file("${sln_srcpath}" "${sln_content}")
endif()
